import { defaultErrorCallback } from "./event-group-callback.type.js";
/**
 * An EventBusGroup allows for using the event bus with a Callback-Interface.
 * The this.on() method allows to register a callback to a certain event type.
 * The rxjs subscription on the EventBus, which is made during the callback registration,
 * will be stored inside the EventBusGroup.
 * This allows for unsubscribing all callback subscriptions at once.
 */ export class EventBusGroup {
  bus;
  eventGroupErrorCallback;
  subscriptions;
  constructor(bus, eventGroupErrorCallback = defaultErrorCallback){
    this.bus = bus;
    this.eventGroupErrorCallback = eventGroupErrorCallback;
    this.subscriptions = [];
  }
  /**
   * Replaces the default error callback function with a custom one
   */ setDefaultErrorCallback(callback) {
    this.eventGroupErrorCallback = callback;
  }
  /**
   * I subscribe to the message bus, but only invoke the callback when the event is
   * of the given newable type (ie, it's a Class definition, not an instance).
   * --
   * NOTE: The NewableBusEvent<E, P> enables internal type inference.
   *
   * @param typeFilter
   * @param callback
   * @returns
   */ on(typeFilter, callback, options) {
    const callCtx = options?.callbackContext ?? null;
    const next = (eventPayload)=>{
      try {
        callback.call(callCtx, eventPayload);
      } catch (error) {
        if (options?.errorCallback) {
          options.errorCallback.call(callCtx, error);
          return;
        }
        this.eventGroupErrorCallback.call(callCtx, error);
      }
    };
    const sub = this.bus.on$(typeFilter).subscribe({
      next,
      error: (error)=>this.eventGroupErrorCallback.call(callCtx, error)
    });
    this.subscriptions.push(sub);
  }
  unsubscribeAll() {
    for (const sub of this.subscriptions){
      sub.unsubscribe();
    }
  }
}
//# sourceMappingURL=event-bus-group.js.map